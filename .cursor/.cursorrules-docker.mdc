# Docker Rules - Docker Compose & Dockerfiles

**You are an expert in Docker, Docker Compose, containerization, and multi-stage builds. Your role is to provide guidance on containerizing Spring Boot and Angular applications, orchestrating services with Docker Compose, and following Docker best practices.**

## Docker Compose Guidelines

### Service Configuration

**Structure:**
- Use `docker-compose.yml` at project root
- Define services: `postgres`, `backend`, `frontend`
- Use environment variables from `.env` file
- Set proper service dependencies: `depends_on`
- Use health checks for service readiness
- Use named networks for service communication

**Example docker-compose.yml:**
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: curseando-postgres
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-curseando}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - curseando-network

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: curseando-backend
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/${POSTGRES_DB:-curseando}
      SPRING_DATASOURCE_USERNAME: ${POSTGRES_USER:-postgres}
      SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SERVER_PORT: 8080
    ports:
      - "${BACKEND_PORT:-8080}:8080"
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    networks:
      - curseando-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        API_URL: http://backend:8080
    container_name: curseando-frontend
    ports:
      - "${FRONTEND_PORT:-4200}:80"
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    networks:
      - curseando-network

volumes:
  postgres_data:
    driver: local

networks:
  curseando-network:
    driver: bridge
```

### PostgreSQL Service

**Configuration:**
- Use official `postgres:15-alpine` or `postgres:16-alpine` image (smaller size)
- Set environment variables: `POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD`
- Use named volumes for data persistence: `postgres_data`
- Expose port 5432 (optional, for direct access)
- Set restart policy: `restart: unless-stopped`
- Add health check: `pg_isready -U postgres`

**Best Practices:**
- Use Alpine images for smaller size
- Use named volumes (not bind mounts) for data persistence
- Set health checks for dependency management
- Use environment variables from `.env` file

### Backend Service

**Configuration:**
- Build from `backend/Dockerfile`
- Depends on `postgres` service with health check condition
- Use environment variables for:
  - Database connection: `SPRING_DATASOURCE_URL`, `SPRING_DATASOURCE_USERNAME`, `SPRING_DATASOURCE_PASSWORD`
  - Application port: `SERVER_PORT=8080`
  - JPA settings: `SPRING_JPA_HIBERNATE_DDL_AUTO=update`
- Expose port 8080
- Use health check: `curl -f http://localhost:8080/actuator/health` (requires Actuator)
- Set restart policy

**Environment Variables:**
```yaml
environment:
  SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/curseando
  SPRING_DATASOURCE_USERNAME: ${POSTGRES_USER:-postgres}
  SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
  SPRING_JPA_HIBERNATE_DDL_AUTO: update
  SPRING_JPA_SHOW_SQL: "false"
  SERVER_PORT: 8080
```

### Frontend Service

**Configuration:**
- Build from `frontend/Dockerfile`
- Depends on `backend` service with health check condition
- Use build args for API URL: `API_URL=http://backend:8080`
- Use environment variables for runtime configuration (if needed)
- Expose port 80 (map to host port 4200 or 3000)
- Use health check: `curl -f http://localhost/`
- Set restart policy

**Build Args:**
```yaml
build:
  context: ./frontend
  dockerfile: Dockerfile
  args:
    API_URL: http://backend:8080
```

### Networking

**Service Communication:**
- Services communicate via Docker network (default: `curseando-network`)
- Use service names as hostnames: `backend`, `postgres`
- Frontend connects to backend: `http://backend:8080`
- Backend connects to postgres: `jdbc:postgresql://postgres:5432/curseando`
- Ports are only exposed to host if needed (for direct access)

**Network Configuration:**
```yaml
networks:
  curseando-network:
    driver: bridge
```

### Environment Variables

**Create `.env` file:**
```bash
# Database
POSTGRES_DB=curseando
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_PORT=5432

# Backend
BACKEND_PORT=8080

# Frontend
FRONTEND_PORT=4200
```

**Best Practices:**
- Create `.env` file at project root
- Add `.env` to `.gitignore`
- Create `.env.example` for reference (without sensitive data)
- Use `${VAR_NAME:-default}` syntax in docker-compose.yml for defaults

## Dockerfile Guidelines

### Backend Dockerfile (Spring Boot)

**Multi-Stage Build:**
```dockerfile
# Stage 1: Build
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app

# Copy pom.xml first (for layer caching)
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Copy source code
COPY src ./src

# Run tests and build application (build fails if tests fail)
RUN mvn clean test package

# Stage 2: Runtime
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from build stage
COPY --from=build /app/target/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# Run application
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**Best Practices:**
- Use multi-stage build to reduce final image size
- Copy `pom.xml` first for better layer caching
- Use `mvn dependency:go-offline` to cache dependencies
- Use Alpine base images for smaller size
- Use non-root user for security
- Add health checks
- Use specific image tags (not `latest`)

### Frontend Dockerfile (Angular)

**Multi-Stage Build:**
```dockerfile
# Stage 1: Build
FROM node:20-alpine AS build
WORKDIR /app

# Copy package files first (for layer caching)
COPY package*.json ./
RUN npm ci --only=production=false

# Copy source code
COPY . .

# Build arguments for environment configuration
ARG API_URL=http://localhost:8080
ENV API_URL=$API_URL

# Run tests (build fails if tests fail)
RUN npm test -- --ci --coverage --passWithNoTests || (echo "Tests failed!" && exit 1)

# Build Angular application
RUN npm run build -- --configuration production

# Stage 2: Runtime
FROM nginx:alpine
WORKDIR /usr/share/nginx/html

# Remove default nginx static assets
RUN rm -rf ./*

# Copy built files from build stage
COPY --from=build /app/dist/curseando/browser .

# Copy nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port
EXPOSE 80

# Health check
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost/ || exit 1

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
```

**Nginx Configuration (nginx.conf):**
```nginx
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/javascript application/json;

    # SPA routing - handle all routes
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
}
```

**Best Practices:**
- Use multi-stage build to reduce final image size
- Copy `package*.json` first for better layer caching
- Use `npm ci` instead of `npm install` for reproducible builds
- Use build args for environment-specific configuration
- Use Alpine base images for smaller size
- Configure nginx for SPA routing
- Add gzip compression
- Cache static assets
- Add security headers

### .dockerignore Files

**Backend .dockerignore:**
```
target/
.mvn/
.idea/
.vscode/
*.iml
*.log
.git/
.gitignore
README.md
.env
```

**Frontend .dockerignore:**
```
node_modules/
dist/
.angular/
.idea/
.vscode/
*.log
.git/
.gitignore
README.md
.env
```

## Best Practices

### Layer Caching
- Copy dependency files first (`pom.xml`, `package.json`)
- Install dependencies before copying source code
- Use specific versions in base images (not `latest`)

### Image Size Optimization
- Use multi-stage builds
- Use Alpine base images
- Remove unnecessary files
- Use `.dockerignore` to exclude files

### Security
- Use non-root users in containers
- Scan images for vulnerabilities
- Use specific image tags (not `latest`)
- Keep base images updated
- Don't expose unnecessary ports

### Health Checks
- Add health checks to all services
- Use appropriate intervals and timeouts
- Set `start_period` for services that take time to start
- Use health checks in `depends_on` conditions

### Volumes
- Use named volumes for data persistence (not bind mounts)
- Use bind mounts only for development (hot reload)
- Document volume usage

### Networking
- Use custom networks for service isolation
- Use service names for inter-service communication
- Only expose ports to host when needed

## Development vs Production

### Development
- Use volume mounts for hot reload:
```yaml
volumes:
  - ./backend/src:/app/src
```
- Enable debug ports:
```yaml
ports:
  - "5005:5005"  # Java debug port
```
- Use `spring.jpa.show-sql=true` for debugging

### Production
- Use separate `docker-compose.prod.yml`
- Remove volume mounts
- Use production builds
- Enable health checks
- Use proper logging configuration
- Set resource limits:
```yaml
deploy:
  resources:
    limits:
      cpus: '1'
      memory: 1G
    reservations:
      cpus: '0.5'
      memory: 512M
```

## Common Commands

**Start services:**
```bash
docker-compose up -d
```

**Stop services:**
```bash
docker-compose down
```

**View logs:**
```bash
docker-compose logs -f [service]
```

**Rebuild images:**
```bash
docker-compose build --no-cache
```

**Restart service:**
```bash
docker-compose restart [service]
```

**Execute command in container:**
```bash
docker-compose exec backend sh
docker-compose exec postgres psql -U postgres -d curseando
```

**View running services:**
```bash
docker-compose ps
```

**Clean up:**
```bash
docker-compose down -v  # Remove volumes
docker system prune -a  # Remove unused images
```

## Troubleshooting

**Backend won't start:**
- Check database connection (wait for postgres health check)
- Check environment variables
- Check logs: `docker-compose logs backend`

**Frontend can't connect to backend:**
- Check backend is running: `docker-compose ps`
- Check network: `docker network ls`
- Check API URL in environment

**Database connection issues:**
- Check postgres is healthy: `docker-compose ps postgres`
- Check connection string uses service name: `postgres:5432`
- Check credentials in `.env` file

**Port conflicts:**
- Change ports in `.env` file
- Check what's using ports: `lsof -i :8080`

## Reference

- Docker Compose documentation: https://docs.docker.com/compose/
- Dockerfile best practices: https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
- Spring Boot Docker guide: https://spring.io/guides/gs/spring-boot-docker/
- Angular Docker guide: https://angular.io/guide/deployment#docker
